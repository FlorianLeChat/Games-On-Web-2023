{"version":3,"file":"physicsBody.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/v2/physicsBody.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IPhysicsCollisionEvent, IPhysicsEnginePluginV2, MassProperties, PhysicsMotionType } from \"./IPhysicsEnginePlugin\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { Mesh, TransformNode, AbstractMesh } from \"../../Meshes\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport { Space } from \"core/Maths/math.axis\";\r\nimport type { Observable, Observer } from \"../../Misc/observable\";\r\nimport type { Node } from \"../../node\";\r\n\r\n/**\r\n * PhysicsBody is useful for creating a physics body that can be used in a physics engine. It allows\r\n * the user to set the mass and velocity of the body, which can then be used to calculate the\r\n * motion of the body in the physics engine.\r\n */\r\nexport class PhysicsBody {\r\n    /**\r\n     * V2 Physics plugin private data for single Transform\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * V2 Physics plugin private data for instances\r\n     */\r\n    public _pluginDataInstances: Array<any> = [];\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    private _physicsPlugin: IPhysicsEnginePluginV2;\r\n    /**\r\n     * The engine used to create and manage this Physics Body\r\n     */\r\n    private _physicsEngine: PhysicsEngine;\r\n    /**\r\n     * The transform node associated with this Physics Body\r\n     */\r\n    transformNode: TransformNode;\r\n    /**\r\n     * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.\r\n     * True by default for maximum performance.\r\n     */\r\n    disablePreStep: boolean = true;\r\n\r\n    private static _DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n    private static _IDENTITY_QUATERNION = Quaternion.Identity();\r\n    private _nodeDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    /**\r\n     * Constructs a new physics body for the given node.\r\n     * @param transformNode - The Transform Node to construct the physics body for.\r\n     * @param motionType - The motion type of the physics body.\r\n     * @param scene - The scene containing the physics engine.\r\n     *\r\n     * This code is useful for creating a physics body for a given Transform Node in a scene.\r\n     * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.\r\n     * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.\r\n     */\r\n    constructor(transformNode: TransformNode, motionType: PhysicsMotionType, scene: Scene) {\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine() as PhysicsEngine;\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        this._physicsEngine = physicsEngine;\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n        if (!transformNode.rotationQuaternion) {\r\n            transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);\r\n        }\r\n        // instances?\r\n        const m = transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.initBodyInstances(this, motionType, m);\r\n        } else {\r\n            // single instance\r\n            this._physicsPlugin.initBody(this, motionType, transformNode.position, transformNode.rotationQuaternion);\r\n        }\r\n        this.transformNode = transformNode;\r\n        transformNode.physicsBody = this;\r\n        physicsEngine.addBody(this);\r\n\r\n        this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clone the PhysicsBody to a new body and assign it to the transformNode parameter\r\n     * @param transformNode transformNode that will be used for the cloned PhysicsBody\r\n     * @returns the newly cloned PhysicsBody\r\n     */\r\n    public clone(transformNode: TransformNode): PhysicsBody {\r\n        const clonedBody = new PhysicsBody(transformNode, this.motionType, this.transformNode.getScene());\r\n        clonedBody.shape = this.shape;\r\n        return clonedBody;\r\n    }\r\n\r\n    /**\r\n     * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.\r\n     */\r\n    public updateBodyInstances() {\r\n        const m = this.transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.updateBodyInstances(this, m);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the physics shape associated with the transform node to this body\r\n     * @param shapeNode - A node with a physics shape. Should be a child of the body node\r\n     */\r\n    public addNodeShape(shapeNode: TransformNode) {\r\n        this._physicsPlugin.addNodeShape(this, shapeNode);\r\n    }\r\n\r\n    /**\r\n     * Sets the shape of the physics body.\r\n     * @param shape - The shape of the physics body.\r\n     *\r\n     * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.\r\n     * The shape is used to calculate the body's mass, inertia, and other properties.\r\n     */\r\n    public set shape(shape: PhysicsShape) {\r\n        this._physicsPlugin.setShape(this, shape);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the physics shape associated with this object.\r\n     *\r\n     * @returns The physics shape associated with this object, or `undefined` if no\r\n     * shape is associated.\r\n     *\r\n     * This method is useful for retrieving the physics shape associated with this object,\r\n     * which can be used to apply physical forces to the object or to detect collisions.\r\n     */\r\n    public get shape(): PhysicsShape {\r\n        return this._physicsPlugin.getShape(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the filter group of the physics body.\r\n     * @param group - The filter group of the physics body.\r\n     *\r\n     * This method is useful for setting the filter group of the physics body.\r\n     * The filter group is used to determine which bodies should collide with each other.\r\n     * This allows for more control over the physics engine and can be used to create more realistic simulations.\r\n     */\r\n    public set filterGroup(group: number) {\r\n        this._physicsPlugin.setFilterGroup(this, group);\r\n    }\r\n\r\n    /**\r\n     * Gets the filter group of the physics engine.\r\n     *\r\n     * @returns The filter group of the physics engine.\r\n     *\r\n     * This method is useful for getting the filter group of the physics engine,\r\n     * which is used to determine which objects will interact with each other.\r\n     * This is important for creating realistic physics simulations.\r\n     */\r\n    public get filterGroup(): number {\r\n        return this._physicsPlugin.getFilterGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the event mask for the physics engine.\r\n     *\r\n     * @param eventMask - A bitmask that determines which events will be sent to the physics engine.\r\n     *\r\n     * This method is useful for setting the event mask for the physics engine, which determines which events\r\n     * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.\r\n     */\r\n    public set eventMask(eventMask: number) {\r\n        this._physicsPlugin.setEventMask(this, eventMask);\r\n    }\r\n\r\n    /**\r\n     * Gets the event mask of the physics engine.\r\n     *\r\n     * @returns The event mask of the physics engine.\r\n     *\r\n     * This method is useful for getting the event mask of the physics engine,\r\n     * which is used to determine which events the engine will respond to.\r\n     * This is important for ensuring that the engine is responding to the correct events and not\r\n     * wasting resources on unnecessary events.\r\n     */\r\n    public get eventMask(): number {\r\n        return this._physicsPlugin.getEventMask(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public set motionType(motionType: PhysicsMotionType) {\r\n        this._physicsPlugin.setMotionType(this, motionType);\r\n    }\r\n\r\n    /**\r\n     * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public get motionType(): PhysicsMotionType {\r\n        return this._physicsPlugin.getMotionType(this);\r\n    }\r\n\r\n    /**\r\n     * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.\r\n     * This method is useful for computing the initial mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass; these values are important for accurately simulating the physics of the\r\n     * object in the physics engine, and computing values based on the shape will provide you with reasonable\r\n     * intial values, which you can then customize.\r\n     */\r\n    public computeMassProperties(): MassProperties {\r\n        return this._physicsPlugin.computeMassProperties(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the mass properties of the physics object.\r\n     *\r\n     * @param massProps - The mass properties to set.\r\n     *\r\n     * This method is useful for setting the mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.\r\n     */\r\n    public set massProperties(massProps: MassProperties) {\r\n        this._physicsPlugin.setMassProperties(this, massProps);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the mass properties of the object.\r\n     *\r\n     * @returns The mass properties of the object.\r\n     *\r\n     * This method is useful for physics simulations, as it allows the user to\r\n     * retrieve the mass properties of the object, such as its mass, center of mass,\r\n     * and moment of inertia. This information is necessary for accurate physics\r\n     * simulations.\r\n     */\r\n    public get massProperties(): MassProperties {\r\n        return this._physicsPlugin.getMassProperties(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear damping of the physics body.\r\n     *\r\n     * @param damping - The linear damping value.\r\n     *\r\n     * This method is useful for controlling the linear damping of the physics body,\r\n     * which is the rate at which the body's velocity decreases over time. This is useful for simulating\r\n     * the effects of air resistance or other forms of friction.\r\n     */\r\n    public set linearDamping(damping: number) {\r\n        this._physicsPlugin.setLinearDamping(this, damping);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear damping of the physics body.\r\n     * @returns The linear damping of the physics body.\r\n     *\r\n     * This method is useful for retrieving the linear damping of the physics body, which is the amount of\r\n     * resistance the body has to linear motion. This is useful for simulating realistic physics behavior\r\n     * in a game.\r\n     */\r\n    public get linearDamping(): number {\r\n        return this._physicsPlugin.getLinearDamping(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular damping of the physics body.\r\n     * @param damping The angular damping of the body.\r\n     *\r\n     * This method is useful for controlling the angular velocity of a physics body.\r\n     * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.\r\n     * This can be used to create realistic physical behavior in a physics engine.\r\n     */\r\n    public set angularDamping(damping: number) {\r\n        this._physicsPlugin.setAngularDamping(this, damping);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular damping of the physics body.\r\n     *\r\n     * @returns The angular damping of the physics body.\r\n     *\r\n     * This method is useful for getting the angular damping of the physics body,\r\n     * which is the rate of reduction of the angular velocity over time.\r\n     * This is important for simulating realistic physics behavior in a game.\r\n     */\r\n    public get angularDamping(): number {\r\n        return this._physicsPlugin.getAngularDamping(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics object.\r\n     * @param linVel - The linear velocity to set.\r\n     *\r\n     * This method is useful for setting the linear velocity of a physics object,\r\n     * which is necessary for simulating realistic physics in a game engine.\r\n     * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.\r\n     * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.\r\n     */\r\n    public setLinearVelocity(linVel: Vector3): void {\r\n        this._physicsPlugin.setLinearVelocity(this, linVel);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of the physics body and stores it in the given vector3.\r\n     * @param linVel - The vector3 to store the linear velocity in.\r\n     *\r\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\r\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.*/\r\n    public getLinearVelocityToRef(linVel: Vector3): void {\r\n        return this._physicsPlugin.getLinearVelocityToRef(this, linVel);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics object.\r\n     * @param angVel - The angular velocity to set.\r\n     *\r\n     * This method is useful for setting the angular velocity of a physics object, which is necessary for\r\n     * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,\r\n     * which is important for simulating realistic motion.\r\n     */\r\n    public setAngularVelocity(angVel: Vector3): void {\r\n        this._physicsPlugin.setAngularVelocity(this, angVel);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of the physics body and stores it in the given vector3.\r\n     * @param angVel - The vector3 to store the angular velocity in.\r\n     *\r\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\r\n     * rotational speed. This information can be used to create realistic physics simulations.\r\n     */\r\n    public getAngularVelocityToRef(angVel: Vector3): void {\r\n        return this._physicsPlugin.getAngularVelocityToRef(this, angVel);\r\n    }\r\n\r\n    /**\r\n     * Applies an impulse to the physics object.\r\n     *\r\n     * @param impulse The impulse vector.\r\n     * @param location The location of the impulse.\r\n     *\r\n     * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyImpulse(impulse: Vector3, location: Vector3): void {\r\n        this._physicsPlugin.applyImpulse(this, impulse, location);\r\n    }\r\n\r\n    /**\r\n     * Applies a force to the physics object.\r\n     *\r\n     * @param force The force vector.\r\n     * @param location The location of the force.\r\n     *\r\n     * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyForce(force: Vector3, location: Vector3): void {\r\n        this._physicsPlugin.applyForce(this, force, location);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the geometry of the body from the physics plugin.\r\n     *\r\n     * @returns The geometry of the body.\r\n     *\r\n     * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.\r\n     */\r\n    public getGeometry(): {} {\r\n        return this._physicsPlugin.getBodyGeometry(this);\r\n    }\r\n\r\n    /**\r\n     * Returns an observable that will be notified for all collisions happening for event-enabled bodies\r\n     * @returns Observable\r\n     */\r\n    public getCollisionObservable(): Observable<IPhysicsCollisionEvent> {\r\n        return this._physicsPlugin.getCollisionObservable(this);\r\n    }\r\n\r\n    /**\r\n     * Enable or disable collision callback for this PhysicsBody.\r\n     * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable\r\n     */\r\n    public setCollisionCallbackEnabled(enabled: boolean): void {\r\n        return this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);\r\n    }\r\n\r\n    /**\r\n     * Gets the object extents\r\n     * @returns the object extents\r\n     */\r\n    public getObjectExtents(): Vector3 {\r\n        const tmAbstractMesh = this.transformNode as AbstractMesh;\r\n        if (tmAbstractMesh.getBoundingInfo) {\r\n            const q = this.transformNode.rotationQuaternion;\r\n            const scaling = this.transformNode.scaling.clone();\r\n            //reset rotation\r\n            this.transformNode.rotationQuaternion = PhysicsBody._IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            const worldMatrix = this.transformNode.computeWorldMatrix && this.transformNode.computeWorldMatrix(true);\r\n            if (worldMatrix) {\r\n                worldMatrix.decompose(scaling, undefined, undefined);\r\n            }\r\n            tmAbstractMesh.refreshBoundingInfo();\r\n            const boundingInfo = tmAbstractMesh.getBoundingInfo();\r\n            // get the global scaling of the object\r\n            const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\r\n            size.x = Math.abs(size.x);\r\n            size.y = Math.abs(size.y);\r\n            size.z = Math.abs(size.z);\r\n            //bring back the rotation\r\n            this.transformNode.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            this.transformNode.computeWorldMatrix && this.transformNode.computeWorldMatrix(true);\r\n            return size;\r\n        } else {\r\n            return PhysicsBody._DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns the delta between the object bounding box center and the mesh origin\r\n     * @returns delta between object bounding box center and origin\r\n     */\r\n    public getObjectCenterDelta(): Vector3 {\r\n        const tmAbstractMesh = this.transformNode as AbstractMesh;\r\n        if (tmAbstractMesh.getBoundingInfo) {\r\n            const delta = new Vector3();\r\n            const boundingInfo = tmAbstractMesh.getBoundingInfo();\r\n            this.transformNode.computeWorldMatrix(true);\r\n            tmAbstractMesh.refreshBoundingInfo();\r\n            delta.copyFrom(boundingInfo.boundingBox.centerWorld);\r\n            delta.subtractInPlace(tmAbstractMesh.getAbsolutePosition());\r\n            delta.x /= tmAbstractMesh.scaling.x;\r\n            delta.y /= tmAbstractMesh.scaling.y;\r\n            delta.z /= tmAbstractMesh.scaling.z;\r\n            return delta;\r\n        } else {\r\n            return Vector3.Zero();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if ((<any>this.transformNode).getBoundingInfo) {\r\n            const boundingInfo = (<any>this.transformNode).getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.transformNode.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a constraint to the physics engine.\r\n     *\r\n     * @param childBody - The body to which the constraint will be applied.\r\n     * @param constraint - The constraint to be applied.\r\n     *\r\n     */\r\n    public addConstraint(childBody: PhysicsBody, constraint: PhysicsConstraint): void {\r\n        this._physicsPlugin.addConstraint(this, childBody, constraint);\r\n    }\r\n\r\n    /**\r\n     * Sync with a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = this.transformNode;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = TmpVectors.Quaternion[0];\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = TmpVectors.Vector3[0];\r\n        const boneDir = TmpVectors.Vector3[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = TmpVectors.Vector3[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    /**\r\n     * Disposes the body from the physics engine.\r\n     *\r\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\r\n     */\r\n    public dispose() {\r\n        if (this._nodeDisposeObserver) {\r\n            this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\r\n            this._nodeDisposeObserver = null;\r\n        }\r\n        this._physicsEngine.removeBody(this);\r\n        this._physicsPlugin.removeBody(this);\r\n        this._physicsPlugin.disposeBody(this);\r\n        this._pluginData = null;\r\n        this._pluginDataInstances.length = 0;\r\n    }\r\n}\r\n"]}