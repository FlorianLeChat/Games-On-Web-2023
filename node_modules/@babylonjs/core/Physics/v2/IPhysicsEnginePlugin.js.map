{"version":3,"file":"IPhysicsEnginePlugin.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/v2/IPhysicsEnginePlugin.ts"],"names":[],"mappings":"AAYA,gBAAgB;AAChB,MAAM,CAAN,IAAY,uBAKX;AALD,WAAY,uBAAuB;IAC/B,qEAAI,CAAA;IACJ,2EAAO,CAAA;IACP,yEAAM,CAAA;IACN,qEAAI,CAAA;AACR,CAAC,EALW,uBAAuB,KAAvB,uBAAuB,QAKlC;AAED,gBAAgB;AAChB,MAAM,CAAN,IAAY,cAQX;AARD,WAAY,cAAc;IACtB,2DAAQ,CAAA;IACR,2DAAQ,CAAA;IACR,2DAAQ,CAAA;IACR,6DAAS,CAAA;IACT,6DAAS,CAAA;IACT,6DAAS,CAAA;IACT,yEAAe,CAAA;AACnB,CAAC,EARW,cAAc,KAAd,cAAc,QAQzB;AAED,gBAAgB;AAChB,MAAM,CAAN,IAAY,cAOX;AAPD,WAAY,cAAc;IACtB,yEAAmB,CAAA;IACnB,2DAAY,CAAA;IACZ,qDAAS,CAAA;IACT,uDAAU,CAAA;IACV,mDAAQ,CAAA;IACR,6DAAa,CAAA;AACjB,CAAC,EAPW,cAAc,KAAd,cAAc,QAOzB;AAED,gBAAgB;AAChB,MAAM,CAAN,IAAY,SASX;AATD,WAAY,SAAS;IACjB,6CAAM,CAAA;IACN,+CAAO,CAAA;IACP,iDAAQ,CAAA;IACR,uCAAG,CAAA;IACH,uDAAW,CAAA;IACX,mDAAS,CAAA;IACT,yCAAI,CAAA;IACJ,uDAAW,CAAA;AACf,CAAC,EATW,SAAS,KAAT,SAAS,QASpB;AAED,gBAAgB;AAChB,MAAM,CAAN,IAAY,mBAIX;AAJD,WAAY,mBAAmB;IAC3B,6DAAI,CAAA;IACJ,qEAAQ,CAAA;IACR,qEAAQ,CAAA;AACZ,CAAC,EAJW,mBAAmB,KAAnB,mBAAmB,QAI9B;AAgJD,MAAM,CAAN,IAAY,iBAIX;AAJD,WAAY,iBAAiB;IACzB,6DAAM,CAAA;IACN,iEAAQ,CAAA;IACR,+DAAO,CAAA;AACX,CAAC,EAJW,iBAAiB,KAAjB,iBAAiB,QAI5B","sourcesContent":["import type { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observable } from \"core/Misc/observable\";\r\n\r\n/** @internal */\r\nexport enum ConstraintAxisLimitMode {\r\n    FREE,\r\n    LIMITED,\r\n    LOCKED,\r\n    NONE,\r\n}\r\n\r\n/** @internal */\r\nexport enum ConstraintAxis {\r\n    LINEAR_X,\r\n    LINEAR_Y,\r\n    LINEAR_Z,\r\n    ANGULAR_X,\r\n    ANGULAR_Y,\r\n    ANGULAR_Z,\r\n    LINEAR_DISTANCE,\r\n}\r\n\r\n/** @internal */\r\nexport enum ConstraintType {\r\n    BALL_AND_SOCKET = 1,\r\n    DISTANCE = 2,\r\n    HINGE = 3,\r\n    SLIDER = 4,\r\n    LOCK = 5,\r\n    PRISMATIC = 6,\r\n}\r\n\r\n/** @internal */\r\nexport enum ShapeType {\r\n    SPHERE,\r\n    CAPSULE,\r\n    CYLINDER,\r\n    BOX,\r\n    CONVEX_HULL,\r\n    CONTAINER,\r\n    MESH,\r\n    HEIGHTFIELD,\r\n}\r\n\r\n/** @internal */\r\nexport enum ConstraintMotorType {\r\n    NONE,\r\n    VELOCITY,\r\n    POSITION,\r\n}\r\n\r\n/**\r\n * Collision object that is the parameter when notification for collision fires.\r\n */\r\nexport interface IPhysicsCollisionEvent {\r\n    /**\r\n     * 1st physics body that collided\r\n     */\r\n    collider: PhysicsBody;\r\n    /**\r\n     * 2nd physics body that collided\r\n     */\r\n    collidedAgainst: PhysicsBody;\r\n    /**\r\n     * World position where the collision occured\r\n     */\r\n    point: Nullable<Vector3>;\r\n    /**\r\n     * Penetration distance\r\n     */\r\n    distance: number;\r\n    /**\r\n     * Impulse value computed by the solver response\r\n     */\r\n    impulse: number;\r\n    /**\r\n     * Collision world normal direction\r\n     */\r\n    normal: Nullable<Vector3>;\r\n}\r\n\r\n/** @internal */\r\nexport interface PhysicsShapeParameters {\r\n    /**\r\n     * Shape center position\r\n     */\r\n    center?: Vector3;\r\n    /**\r\n     * Radius for cylinder, shape and capsule\r\n     */\r\n    radius?: number;\r\n    /**\r\n     * First point position that defines the cylinder or capsule\r\n     */\r\n    pointA?: Vector3;\r\n    /**\r\n     * Second point position that defines the cylinder or capsule\r\n     */\r\n    pointB?: Vector3;\r\n    /**\r\n     *\r\n     */\r\n    rotation?: Quaternion;\r\n    /**\r\n     * Dimesion extention for the box\r\n     */\r\n    extents?: Vector3;\r\n    /**\r\n     * Mesh used for Mesh shape or convex hull. It can be different than the mesh the body is attached to.\r\n     */\r\n    mesh?: Mesh;\r\n    /**\r\n     * Use children hierarchy\r\n     */\r\n    includeChildMeshes?: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport interface PhysicsConstraintParameters {\r\n    /**\r\n     * Pivot vector for 1st body\r\n     */\r\n    pivotA?: Vector3;\r\n    /**\r\n     * Pivot vector for 2nd body\r\n     */\r\n    pivotB?: Vector3;\r\n    /**\r\n     * Axis vector for 1st body\r\n     */\r\n    axisA?: Vector3;\r\n    /**\r\n     * Axis vector for 2nd body\r\n     */\r\n    axisB?: Vector3;\r\n    /**\r\n     * Maximum distance between both bodies\r\n     */\r\n    maxDistance?: number;\r\n    /**\r\n     * Can connected bodies collide?\r\n     */\r\n    collision?: boolean;\r\n}\r\n\r\n/**\r\n *\r\n */\r\n/** @internal */\r\nexport interface MassProperties {\r\n    /**\r\n     * The center of mass, in local space. This is The\r\n     * point the body will rotate around when applying\r\n     * an angular velocity.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    centerOfMass?: Vector3;\r\n    /**\r\n     * The total mass of this object, in kilograms. This\r\n     * affects how easy it is to move the body. A value\r\n     * of zero will be used as an infinite mass.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    mass?: number;\r\n    /**\r\n     * The principal moments of inertia of this object\r\n     * for a unit mass. This determines how easy it is\r\n     * for the body to rotate. A value of zero on any\r\n     * axis will be used as infinite interia about that\r\n     * axis.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    inertia?: Vector3;\r\n    /**\r\n     * The rotation rotating from inertia major axis space\r\n     * to parent space (i.e., the rotation which, when\r\n     * applied to the 3x3 inertia tensor causes the inertia\r\n     * tensor to become a diagonal matrix). This determines\r\n     * how the values of inertia are aligned with the parent\r\n     * object.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    inertiaOrientation?: Quaternion;\r\n}\r\n\r\nexport enum PhysicsMotionType {\r\n    STATIC,\r\n    ANIMATED,\r\n    DYNAMIC,\r\n}\r\n\r\n/** @internal */\r\nexport interface IPhysicsEnginePluginV2 {\r\n    /**\r\n     * Physics plugin world instance\r\n     */\r\n    world: any;\r\n    /**\r\n     * Physics plugin name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Collision observable\r\n     */\r\n    onCollisionObservable: Observable<{\r\n        collider: PhysicsBody;\r\n        collidedAgainst: PhysicsBody;\r\n        point: Nullable<Vector3>;\r\n        distance: number;\r\n        impulse: number;\r\n        normal: Nullable<Vector3>;\r\n    }>;\r\n\r\n    setGravity(gravity: Vector3): void;\r\n    setTimeStep(timeStep: number): void;\r\n    getTimeStep(): number;\r\n    executeStep(delta: number, bodies: Array<PhysicsBody>): void; //not forgetting pre and post events\r\n    getPluginVersion(): number;\r\n\r\n    // body\r\n    initBody(body: PhysicsBody, motionType: PhysicsMotionType, position: Vector3, orientation: Quaternion): void;\r\n    initBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, mesh: Mesh): void;\r\n    updateBodyInstances(body: PhysicsBody, mesh: Mesh): void;\r\n    removeBody(body: PhysicsBody): void;\r\n    sync(body: PhysicsBody): void;\r\n    syncTransform(body: PhysicsBody, transformNode: TransformNode): void;\r\n    addNodeShape(body: PhysicsBody, shapeNode: TransformNode): void;\r\n    setShape(body: PhysicsBody, shape: PhysicsShape): void;\r\n    getShape(body: PhysicsBody): PhysicsShape;\r\n    getShapeType(shape: PhysicsShape): ShapeType;\r\n    setFilterGroup(body: PhysicsBody, group: number): void;\r\n    getFilterGroup(body: PhysicsBody): number;\r\n    setEventMask(body: PhysicsBody, eventMask: number): void;\r\n    getEventMask(body: PhysicsBody): number;\r\n    setMotionType(body: PhysicsBody, motionType: PhysicsMotionType): void;\r\n    getMotionType(body: PhysicsBody): PhysicsMotionType;\r\n    computeMassProperties(body: PhysicsBody): MassProperties;\r\n    setMassProperties(body: PhysicsBody, massProps: MassProperties): void;\r\n    getMassProperties(body: PhysicsBody): MassProperties;\r\n    setLinearDamping(body: PhysicsBody, damping: number): void;\r\n    getLinearDamping(body: PhysicsBody): number;\r\n    setAngularDamping(body: PhysicsBody, damping: number): void;\r\n    getAngularDamping(body: PhysicsBody): number;\r\n    setLinearVelocity(body: PhysicsBody, linVel: Vector3): void;\r\n    getLinearVelocityToRef(body: PhysicsBody, linVel: Vector3): void;\r\n    applyImpulse(body: PhysicsBody, impulse: Vector3, location: Vector3): void;\r\n    applyForce(body: PhysicsBody, force: Vector3, location: Vector3): void;\r\n    setAngularVelocity(body: PhysicsBody, angVel: Vector3): void;\r\n    getAngularVelocityToRef(body: PhysicsBody, angVel: Vector3): void;\r\n    getBodyGeometry(body: PhysicsBody): {};\r\n    disposeBody(body: PhysicsBody): void;\r\n    setCollisionCallbackEnabled(body: PhysicsBody, enabled: boolean): void;\r\n    addConstraint(body: PhysicsBody, childBody: PhysicsBody, constraint: PhysicsConstraint): void;\r\n    getCollisionObservable(body: PhysicsBody): Observable<IPhysicsCollisionEvent>;\r\n\r\n    // shape\r\n    initShape(shape: PhysicsShape, type: ShapeType, options: PhysicsShapeParameters): void;\r\n    setFilterLayer(shape: PhysicsShape, layer: number): void;\r\n    getFilterLayer(shape: PhysicsShape): number;\r\n    setMaterial(shape: PhysicsShape, material: PhysicsMaterial): void;\r\n    setDensity(shape: PhysicsShape, density: number): void;\r\n    getDensity(shape: PhysicsShape): number;\r\n    addChild(shape: PhysicsShape, newChild: PhysicsShape, childTransform: TransformNode): void;\r\n    removeChild(shape: PhysicsShape, childIndex: number): void;\r\n    getNumChildren(shape: PhysicsShape): number;\r\n    getBoundingBox(shape: PhysicsShape): BoundingBox;\r\n    disposeShape(shape: PhysicsShape): void;\r\n\r\n    // constraint\r\n    initConstraint(constraint: PhysicsConstraint, body: PhysicsBody, childBody: PhysicsBody): void;\r\n    setEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void;\r\n    getEnabled(constraint: PhysicsConstraint): boolean;\r\n    setCollisionsEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void;\r\n    getCollisionsEnabled(constraint: PhysicsConstraint): boolean;\r\n    setAxisFriction(constraint: PhysicsConstraint, axis: ConstraintAxis, friction: number): void;\r\n    getAxisFriction(constraint: PhysicsConstraint, axis: ConstraintAxis): number;\r\n    setAxisMode(constraint: PhysicsConstraint, axis: ConstraintAxis, limitMode: ConstraintAxisLimitMode): void;\r\n    getAxisMode(constraint: PhysicsConstraint, axis: ConstraintAxis): ConstraintAxisLimitMode;\r\n    setAxisMinLimit(constraint: PhysicsConstraint, axis: ConstraintAxis, minLimit: number): void;\r\n    getAxisMinLimit(constraint: PhysicsConstraint, axis: ConstraintAxis): number;\r\n    setAxisMaxLimit(constraint: PhysicsConstraint, axis: ConstraintAxis, limit: number): void;\r\n    getAxisMaxLimit(constraint: PhysicsConstraint, axis: ConstraintAxis): number;\r\n    setAxisMotorType(constraint: PhysicsConstraint, axis: ConstraintAxis, motorType: ConstraintMotorType): void;\r\n    getAxisMotorType(constraint: PhysicsConstraint, axis: ConstraintAxis): ConstraintMotorType;\r\n    setAxisMotorTarget(constraint: PhysicsConstraint, axis: ConstraintAxis, target: number): void;\r\n    getAxisMotorTarget(constraint: PhysicsConstraint, axis: ConstraintAxis): number;\r\n    setAxisMotorMaxForce(constraint: PhysicsConstraint, axis: ConstraintAxis, maxForce: number): void;\r\n    getAxisMotorMaxForce(constraint: PhysicsConstraint, axis: ConstraintAxis): number;\r\n    disposeConstraint(constraint: PhysicsConstraint): void;\r\n\r\n    // raycast\r\n    raycast(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void;\r\n\r\n    dispose(): void;\r\n}\r\n"]}